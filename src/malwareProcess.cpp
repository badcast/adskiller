#include <QTimer>
#include <QHash>
#include <QDesktopServices>
#include <QUrl>
#include <QMessageBox>
#include <QStringListModel>
#include <QCryptographicHash>
#include <QThread>
#include <QMutex>
#include <QMutexLocker>
#include <QEventLoop>

#include "mainwindow.h"
#include "network.h"
#include "adbtrace.h"

#define WAITMODE if(malwareCmd == MalwareForclyKill) break; QThread::msleep(400)
#define WAITMODE2 if(malwareCmd == MalwareForclyKill) break; QThread::msleep(50)

enum
{
    MalwareExecFail = -1,
    MalwareForclyKill = -2
};

enum
{
    MalwareNoError = 0,
    MalwareNoNetwork = 1000
};

QStringList _outputMalware;
QThread * malwareThread;
QMutex *mutex;
MainWindow *mainWindow;
MalwareStatus status;
Network * network;
Adb * adb;
int malwareCmd;

QStringList malwareReadLog();
MalwareStatus malwareStatus();
void malwareStart();
void malwareKill();
void malwareClean();
void malwaring();

void malwareWriteLog(QString msg)
{
    QMutexLocker locker(mutex);
    _outputMalware << std::move(msg);
}

QStringList malwareReadLog(){
    QMutexLocker locker(mutex);
    QStringList copy;
    copy = _outputMalware;
    _outputMalware.clear();
    return copy;
}

MalwareStatus malwareStatus(){
    return status;
}

void malwareStart(MainWindow * handler){
    if(malwareThread != nullptr)
    {
        malwareWriteLog("Процесс уже запущен.");
        return;
    }
    mutex = new QMutex();
    mainWindow = handler;
    malwareThread = new QThread();
    adb = &handler->adb;
    network = new Network(handler);
    network->authedId = handler->network.authedId;
    malwareCmd = 0;
    status = MalwareStatus::Running;
    QObject::connect(malwareThread, &QThread::started, &malwaring);
    malwareThread->start(QThread::HighPriority);
}

void malwareClean()
{
    if(status == MalwareStatus::Running)
        return;
    delete network;
    delete mutex;
    malwareThread = nullptr;
}

void malwareKill(){
    if(malwareThread == nullptr)
        return;
    malwareCmd = MalwareForclyKill;
}

void malwaring()
{
    int isFinish = 0;
    int lastResult;
    QList<PackageIO> localPackages;
    QEventLoop loop;

    while(!isFinish)
    {
        switch(malwareCmd)
        {
            // INIT
        case 0:
        {
            malwareWriteLog("Запуск процедуры удаление рекламы (Malware)...");
            malwareCmd++;
            WAITMODE;
            break;
        }
        // GET PACKAGES & UPLOAD
        case 1:
        {
            malwareWriteLog(QString("Получение данных с устройства ") + adb->device.displayName + "(" + adb->device.devId + ")");
            if(!adb->isConnected())
            {
                malwareWriteLog("Устройство внезапно отключилась.");
                malwareCmd = MalwareExecFail;
                break;
            }
            localPackages = adb->getPackages();
            if(adb->isConnected())
            {
                if(localPackages.isEmpty())
                {
                    malwareWriteLog("Ваше устройство не имеет вирусов.");
                    malwareCmd = MalwareExecFail;
                    break;
                }
            }
            else
            {
                malwareWriteLog("Устройство внезапно отключилась.");
                malwareCmd = MalwareExecFail;
                break;
            }
            malwareWriteLog("Распаковка");
            WAITMODE;
            for(const PackageIO& pkg : localPackages)
            {
                malwareWriteLog(" >> md5 hash " + QString(QCryptographicHash::hash(pkg.packageName.toLatin1(), QCryptographicHash::Md5).toHex()));
                WAITMODE2;
            }
            malwareWriteLog("Получение данных завершена успешно.");
            WAITMODE;

            QStringList resultList;
            QString mdKey;
            std::transform(localPackages.begin(), localPackages.end(), std::back_inserter(resultList), [](const PackageIO& pkgIO){ return pkgIO.packageName; });
            QObject::connect(network, &Network::uploadUserPackages, [&lastResult,&mdKey,&loop](int status, const QString& mdK, bool ok)
                             {
                                 if(!ok)
                                     mainWindow->showMessageFromStatus(status);
                                 mdKey = mdK;
                                 lastResult = status;
                                 loop.quit();
                             });
            network->sendUserPackages(adb->device, resultList);
            malwareWriteLog("Отправка образцов на сервер imister.kz и получение md-ключа");
            loop.exec();
            WAITMODE;

            if(lastResult)
            {
                malwareWriteLog("Возникла ошибка.");
                if(lastResult == NetworkStatus::NoEnoughMoney)
                    malwareWriteLog("Пополните баланс, чтобы продолжить.");
                else
                    malwareWriteLog(QString("Код ошибки %1").arg(lastResult));
                WAITMODE;
                malwareCmd = MalwareExecFail;
                break;
            }
            malwareWriteLog(QString("md-ключ получен ") + mdKey);
            malwareWriteLog("Применение md-ключа и получение лабараторного анализа.");
            WAITMODE;

            network->getAds(mdKey);
            resultList.clear();
            QObject::connect(network, &Network::adsFinished, [&](const QStringList& adsData, int status, bool ok)
                             {
                                 if(ok)
                                 {
                                     resultList = adsData;
                                 }
                                 lastResult = status;
                                 loop.quit();
                             });
            loop.exec();
            if(lastResult != NetworkStatus::OK)
            {
                malwareWriteLog("Ошибка во время получения.");
                if(lastResult == NetworkStatus::ServerError)
                    malwareWriteLog("Ошибка на стороне сервера.");
                else if(lastResult == NetworkStatus::NoEnoughMoney)
                    malwareWriteLog("Пополните баланс, чтобы продолжить.");
                else
                    malwareWriteLog(QString("Код ошибки %1").arg(lastResult));
                WAITMODE;
                malwareCmd = MalwareExecFail;
                break;
            }
            malwareWriteLog("Результаты из лаборатории получены.");
            WAITMODE;

            malwareWriteLog("--------------------------------------------------------");

            if(resultList.isEmpty())
            {
                malwareWriteLog("К сожалению, автоматический режим не обнаружил вредоносного ПО.");
                malwareWriteLog("Пожалуйста, подождите несколько минут и попробуйте снова. ");
                malwareWriteLog("Администратор проверит систему на наличие рекламных вирусов.");
                malwareCmd++;
                break;
            }

            malwareWriteLog("Распаковка");
            WAITMODE;
            for(const QString& pkg : resultList)
            {
                malwareWriteLog(" >> md5 hash " + QString(QCryptographicHash::hash(pkg.toLatin1(), QCryptographicHash::Md5).toHex()));
                WAITMODE2;
            }

            malwareWriteLog("Обезвреживание устройства. Ждите...");
            lastResult=0;
            if(!adb->uninstallPackages(resultList,lastResult))
            {
                malwareWriteLog("Что-то пошло не так. Возможно устройство было отключено.");
                malwareWriteLog("Пожалуйста начните процедуру заново.");
                WAITMODE;
                malwareCmd = MalwareExecFail;
                break;
            }

            if(lastResult != resultList.size())
            {
                malwareWriteLog("Предупреждение: Процесс частично успешен. Повторите.");
            }
            malwareCmd++;
            break;
        }
        default:
            isFinish = 1;
            malwareWriteLog("--------------------------------------------------------");
            if(malwareCmd < 0)
            {
                malwareWriteLog("Процедура завершилась ошибкой.");
                status = MalwareStatus::Error;
            }
            else
            {
                malwareWriteLog("Процедура завершена.");
                status = MalwareStatus::Idle;
            }
            break;
        }
    }
}

#undef WAITMODE
