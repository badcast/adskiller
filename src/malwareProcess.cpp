#include <QTimer>
#include <QHash>
#include <QDesktopServices>
#include <QUrl>
#include <QMessageBox>
#include <QStringListModel>
#include <QCryptographicHash>
#include <QThread>
#include <QMutex>
#include <QMutexLocker>
#include <QEventLoop>

#include "mainwindow.h"
#include "network.h"
#include "adbfront.h"

#define WAITMODE if(malwareCmd == MalwareForclyKill) break; QThread::msleep(400)
#define WAITMODE2 if(malwareCmd == MalwareForclyKill) break; QThread::msleep(50)
#define PRINT_LINE malwareWriteLog("--------------------------------------------------------")

enum
{
    MalwareExecFail = -1,
    MalwareForclyKill = -2
};

enum
{
    MalwareNoError = 0,
    MalwareNoNetwork = 1000
};

QStringList _outputMalware;
QThread * malwareThread;
QMutex *mutex;
MainWindow *mainWindow;
MalwareStatus status;
Network * network;
Adb * adb;
int mProgress;
int malwareCmd;

QPair<QStringList,int> malwareReadLog();
MalwareStatus malwareStatus();
void malwareStart();
void malwareKill();
void malwareClean();
void malwaring();

template <typename InT, typename OutT>
constexpr OutT Map(const InT x, const InT in_min, const InT in_max, const OutT out_min, const OutT out_max)
{
    return static_cast<OutT>((x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min);
}

int percentageCalc(int start, int end, int deltaValue, int deltaHigh, int deltaLow = 0)
{
    int retval;
    retval = Map<int>(deltaValue,deltaLow,deltaHigh,start,end);
    return retval;
}

void malwareWriteLog(QString msg, int progress = -1)
{
    QMutexLocker locker(mutex);
    _outputMalware << std::move(msg);
    if(progress > -1)
        mProgress = progress;
}

QPair<QStringList, int> malwareReadLog(){
    QMutexLocker locker(mutex);
    return {QStringList(std::move(_outputMalware)),mProgress};
}

MalwareStatus malwareStatus(){
    return status;
}

void malwareStart(MainWindow * handler){
    if(malwareThread != nullptr)
    {
        malwareWriteLog("Процесс уже запущен.");
        return;
    }
    mutex = new QMutex();
    mainWindow = handler;
    malwareThread = new QThread();
    adb = &handler->adb;
    network = new Network(handler);
    network->authedId = handler->network.authedId;
    malwareCmd = 0;
    mProgress = 0;
    status = MalwareStatus::Running;
    QObject::connect(malwareThread, &QThread::started, &malwaring);
    malwareThread->start(QThread::HighPriority);
}

void malwareClean()
{
    if(status == MalwareStatus::Running)
        return;
    delete network;
    delete mutex;
    malwareThread = nullptr;
}

void malwareKill(){
    if(malwareThread == nullptr)
        return;
    malwareCmd = MalwareForclyKill;
}

void malwaring()
{
    int isFinish = 0;
    int lastResult,num0,num1;
    QList<PackageIO> localPackages;
    QEventLoop loop;

    while(!isFinish)
    {
        switch(malwareCmd)
        {
            // INIT
        case 0:
        {
            malwareWriteLog("Запуск процедуры удаление рекламы (Malware)...", 0);
            malwareCmd++;
            WAITMODE;
            break;
        }
        // GET PACKAGES & UPLOAD
        case 1:
        {
            malwareWriteLog(QString("Получение данных с устройства ") + adb->device.displayName + "(" + adb->device.devId + ")", 5);
            if(!adb->isConnected())
            {
                malwareWriteLog("Устройство внезапно отключилась.");
                malwareCmd = MalwareExecFail;
                break;
            }
            localPackages = adb->getPackages();
            if(adb->isConnected())
            {
                if(localPackages.isEmpty())
                {
                    malwareWriteLog("Ваше устройство не имеет вирусов.");
                    malwareCmd = MalwareExecFail;
                    break;
                }
            }
            else
            {
                malwareWriteLog("Устройство внезапно отключилась.");
                malwareCmd = MalwareExecFail;
                break;
            }
            malwareWriteLog("Распаковка");
            WAITMODE;

            num0 = mProgress;
            num1 = 1;
            for(const PackageIO& pkg : std::as_const(localPackages))
            {
                int curValue = percentageCalc(num0,50,num1,localPackages.size());
                malwareWriteLog(QString(" >> md5 hash %1").arg(QString(QCryptographicHash::hash(pkg.packageName.toLatin1(), QCryptographicHash::Md5).toHex())), curValue);
                WAITMODE2;
                ++num1;
            }
            malwareWriteLog("Получение данных завершена успешно.");
            malwareWriteLog("Анализ и обработка фоновых данных...");
            adb->killPackages(localPackages);
            malwareWriteLog("Выполнено.");
            WAITMODE;

            QStringList resultList;
            QString mdKey;
            std::transform(localPackages.begin(), localPackages.end(), std::back_inserter(resultList), [](const PackageIO& package){ return package.packageName; });
            QObject::connect(network, &Network::uploadUserPackages, [&lastResult,&mdKey,&loop](int status, const QString& mdKeyFrom, bool ok)
                             {
                                 if(!ok)
                                     mainWindow->showMessageFromStatus(status);
                                 mdKey = mdKeyFrom;
                                 lastResult = status;
                                 loop.quit();
                             });
            network->sendUserPackages(adb->device, resultList);
            malwareWriteLog("Отправка образцов на сервер imister.kz и получение md-ключа", 51);
            loop.exec();
            WAITMODE;

            if(lastResult)
            {
                malwareWriteLog("Возникла ошибка.");
                if(lastResult == NetworkStatus::NoEnoughMoney)
                    malwareWriteLog("Пополните баланс, чтобы продолжить.");
                else
                    malwareWriteLog(QString("Код ошибки %1").arg(lastResult));
                WAITMODE;
                malwareCmd = MalwareExecFail;
                break;
            }
            malwareWriteLog(QString("md-ключ получен ") + mdKey, 52);
            malwareWriteLog("Применение md-ключа и получение лабараторного анализа.", 53);
            WAITMODE;

            network->getAdsData(mdKey);
            resultList.clear();
            QObject::connect(network, &Network::labStatusFinish, [&](const QStringList& adsData, int status, bool ok)
                             {
                                 (void)lastResult;
                                 (void)loop;
                                 if(ok)
                                     resultList = adsData;
                                 lastResult = status;
                                 loop.quit();
                             });
            loop.exec();
            if(lastResult != NetworkStatus::OK)
            {
                malwareWriteLog("Ошибка во время получения.");
                if(lastResult == NetworkStatus::ServerError)
                    malwareWriteLog("Ошибка на стороне сервера.");
                else if(lastResult == NetworkStatus::NoEnoughMoney)
                    malwareWriteLog("Пополните баланс, чтобы продолжить.");
                else
                    malwareWriteLog(QString("Код ошибки %1").arg(lastResult));
                WAITMODE;
                malwareCmd = MalwareExecFail;
                break;
            }
            malwareWriteLog("Результаты из лаборатории получены.",55);
            WAITMODE;

            PRINT_LINE;

            if(resultList.isEmpty())
            {
                malwareWriteLog("К сожалению, автоматический режим не обнаружил вредоносного ПО.");
                malwareWriteLog("Пожалуйста, подождите несколько минут и попробуйте снова. ");
                malwareWriteLog("Кибер-специалист проверит ваше устройство на наличие рекламных вирусов.", 100);
                malwareCmd++;
                WAITMODE;
                break;
            }

            malwareWriteLog("Распаковка", 57);
            WAITMODE;

            num0 = mProgress;
            num1 = 1;
            for(const QString& pkg : std::as_const(resultList))
            {
                int curValue = percentageCalc(num0,80,num1,localPackages.size());
                malwareWriteLog(QString(" >> md5 hash %1").arg(QString(QCryptographicHash::hash(pkg.toLatin1(), QCryptographicHash::Md5).toHex())), curValue);
                WAITMODE2;
                ++num1;
            }
            WAITMODE;

            malwareWriteLog("Обезвреживание устройства. Ждите...",81);
            lastResult=0;
            if(!adb->uninstallPackages(resultList,lastResult))
            {
                malwareWriteLog("Что-то пошло не так. Возможно устройство было отключено.");
                malwareWriteLog("Пожалуйста начните процедуру заново.");
                WAITMODE;
                malwareCmd = MalwareExecFail;
                break;
            }

            mProgress = percentageCalc(mProgress, 99, lastResult, resultList.size());
            if(lastResult != resultList.size())
                malwareWriteLog("Предупреждение: Процесс частично успешен. Повторите.");
            else
                mProgress = 100;
            malwareCmd++;
            break;
        }
        default:
            PRINT_LINE;

            isFinish = 1;
            if(malwareCmd < 0)
            {
                malwareWriteLog("Процедура завершилась ошибкой.");
                status = MalwareStatus::Error;
            }
            else
            {
                malwareWriteLog("Процедура завершена.");
                status = MalwareStatus::Idle;
            }
            break;
        }
    }
}

#undef WAITMODE
