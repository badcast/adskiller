#include <QTimer>
#include <QHash>
#include <QDesktopServices>
#include <QUrl>
#include <QMessageBox>
#include <QStringListModel>
#include <QThread>
#include <QEventLoop>

#include "mainwindow.h"
#include "network.h"
#include "adbtrace.h"

enum
{
    MalwareExecFail = -1,
    MalwareForclyKill = -2
};

enum
{
    MalwareNoError = 0,
    MalwareNoNetwork = 1000
};

QThread * malwareThread;
QStringList processOutput;
MainWindow *mainWindow;
MalwareStatus status;
Network * network;
Adb * adb;
int malwareCmd;

QStringList malwareRead();
MalwareStatus malwareStatus();
void malwareStart();
void malwareKill();
void malwareClean();
void malwaring();

void malware_wait()
{
    QThread::msleep(500);
}

#define WAITMODE if(malwareCmd == MalwareForclyKill) break; malware_wait()


void writeLog(QString msg)
{
    processOutput << std::move(msg);
}

QStringList malwareRead(){
    QStringList copy = processOutput;
    processOutput.clear();
    return copy;
}

MalwareStatus malwareStatus(){
    return status;
}

void malwareStart(MainWindow * handler){
    if(malwareThread != nullptr)
    {
        writeLog("Процесс уже запущен.");
        return;
    }
    mainWindow = handler;
    malwareThread = new QThread();
    adb = &handler->adb;
    network = new Network(handler);
    network->authedId = handler->network.authedId;
    malwareCmd = 0;
    status = MalwareStatus::Running;
    QObject::connect(malwareThread, &QThread::started, &malwaring);
    malwareThread->start(QThread::HighPriority);
}

void malwareClean()
{
    if(status == MalwareStatus::Running)
        return;
    delete network;
    malwareThread = nullptr;
}

void malwareKill(){
    if(malwareThread == nullptr)
        return;
    malwareCmd = MalwareForclyKill;
}

void malwaring()
{
    int isFinish = 0;
    int lastResult;
    QList<PackageIO> localPackages;
    QEventLoop loop;

    while(!isFinish)
    {
        switch(malwareCmd)
        {
            // INIT
        case 0:
        {
            writeLog("Инициализация Malware...");
            malwareCmd++;
            WAITMODE;
            break;
        }
        // GET PACKAGES & UPLOAD
        case 1:
        {
            writeLog(QString("Получение данных с устройства ") + adb->device.displayName);
            if(!adb->isConnected())
            {
                writeLog("Устройство внезапно отключилась.");
                malwareCmd = MalwareExecFail;
                break;
            }
            localPackages = adb->getPackages();
            if(adb->isConnected())
            {
                if(localPackages.isEmpty())
                {
                    writeLog("Ваше устройство не имеет вирусов.");
                    malwareCmd = MalwareExecFail;
                    break;
                }
            }
            else
            {
                writeLog("Устройство внезапно отключилась.");
                malwareCmd = MalwareExecFail;
                break;
            }
            writeLog("Получение данных завершена успешно.");
            WAITMODE;

            QStringList resultList;
            QString mdKey;
            std::transform(localPackages.begin(), localPackages.end(), std::back_inserter(resultList), [](const PackageIO& pkgIO){ return pkgIO.packageName; });
            QObject::connect(network, &Network::uploadUserPackages, [&](int status, const QString& mdK, bool ok)
                             {
                                 if(!ok)
                                     mainWindow->showMessageFromStatus(status);
                                 mdKey = mdK;
                                 lastResult = status;
                                 loop.quit();
                             });
            network->sendUserPackages(adb->device, resultList);
            writeLog("Отправка образцов на сервер imister.kz и получение md-ключа");
            loop.exec();
            WAITMODE;

            if(lastResult)
            {
                writeLog("Возникла ошибка.");
                if(lastResult == NetworkStatus::NoEnoughMoney)
                    writeLog("Пополните баланс, чтобы продолжить.");
                else
                    writeLog(QString("Код ошибки %1").arg(lastResult));
                WAITMODE;
                malwareCmd = MalwareExecFail;
                break;
            }
            writeLog(QString("md-ключ получен ") + mdKey);
            writeLog("Применение md-ключа и получение лабараторного анализа.");
            WAITMODE;

            network->getAds(mdKey);
            resultList.clear();
            QObject::connect(network, &Network::adsFinished, [&](const QStringList& adsData, int status, bool ok)
                             {
                                 if(ok)
                                 {
                                     resultList = adsData;
                                 }
                                 lastResult = status;
                                 loop.quit();
                             });
            loop.exec();
            if(lastResult != NetworkStatus::OK)
            {
                writeLog("Ошибка во время получения.");
                if(lastResult == NetworkStatus::ServerError)
                    writeLog("Ошибка на стороне сервера.");
                else if(lastResult == NetworkStatus::NoEnoughMoney)
                    writeLog("Пополните баланс, чтобы продолжить.");
                else
                    writeLog(QString("Код ошибки %1").arg(lastResult));
                WAITMODE;
                malwareCmd = MalwareExecFail;
                break;
            }
            writeLog("Результаты из лаборатории получены.");
            WAITMODE;

            writeLog("--------------------------------------------------------");

            if(resultList.isEmpty())
            {
                writeLog("К сожалению, автоматический режим не обнаружил вредоносного ПО.");
                writeLog("Пожалуйста, подождите несколько минут и попробуйте снова. ");
                writeLog("Администратор проверит систему на наличие рекламных вирусов.");
                malwareCmd++;
                break;
            }

            writeLog("Обезвреживание устройства. Ждите...");
            if(!adb->uninstallPackages(resultList))
            {
                writeLog("Что-то пошло не так. Возможно устройство было отключено.");
                writeLog("Пожалуйста начните процедуру заново.");
                WAITMODE;
                malwareCmd = MalwareExecFail;
                break;
            }

            malwareCmd++;
            break;
        }
        default:
            isFinish = 1;

            writeLog("--------------------------------------------------------");

            if(malwareCmd < 0)
            {
                writeLog("Процедура завершилась ошибкой.");
                status = MalwareStatus::Error;
            }
            else
            {
                writeLog("Процедура завершена.");
                status = MalwareStatus::Idle;
            }
            break;
        }
    }
}

#undef WAITMODE
