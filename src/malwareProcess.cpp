#include <chrono>

#include <QTimer>
#include <QHash>
#include <QDesktopServices>
#include <QUrl>
#include <QMessageBox>
#include <QStringListModel>
#include <QCryptographicHash>
#include <QThread>
#include <QMutex>
#include <QMutexLocker>
#include <QEventLoop>

#include "mainwindow.h"
#include "network.h"
#include "adbfront.h"

#define FORCLYQUIT_CHECK if(malwareCmd == MalwareForclyKill) break
#define WAITMODE FORCLYQUIT_CHECK; QThread::msleep(400)
#define WAITMODE2 FORCLYQUIT_CHECK; QThread::msleep(50)
#define PRINT_LINE malwareWriteLog("--------------------------------------------------------")

enum
{
    MalwareExecFail = -1,
    MalwareForclyKill = -2
};

enum
{
    MalwareNoError = 0,
    MalwareNoNetwork = 1000
};

QStringList _outputMalware;
QString _outputHeader;
QThread * malwareThread;
QMutex *mutex;
MainWindow *mainWindow;
MalwareStatus status;
Network * network;
Adb * adb;
int mProgress;
int malwareCmd;
int malwareUserValue;

std::pair<QStringList, int> malwareReadLog();
QString malwareReadHeader();
MalwareStatus malwareStatus();
void malwareStart();
void malwareKill();
bool malwareClean();
void malwaring();
void malwareWriteVal(int userValue);
bool malwareRequireUser();

template <typename InT, typename OutT>
constexpr inline OutT Map(const InT x, const InT in_min, const InT in_max, const OutT out_min, const OutT out_max)
{
    if (in_max == in_min) {
        return out_min;
    }
    OutT mapped_value = (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    return qMin(qMax(mapped_value, out_min), out_max);
}

void malwareWriteVal(int userValue){
    QMutexLocker locker(mutex);
    (void)locker;
    malwareUserValue = userValue;
}

bool malwareRequireUser(){
    return malwareUserValue == 1000;
}

void malwareWriteLog(QString msg, int progress = -1)
{
    QMutexLocker locker(mutex);
    _outputMalware << std::move(msg);
    if(progress > -1)
        mProgress = progress;
}

void malwareWriteHeader(QString msg, int progress = -1)
{
    QMutexLocker locker(mutex);
    _outputHeader = std::move(msg);
    _outputMalware << _outputHeader;
    if(progress > -1)
        mProgress = progress;
}

template<typename T0, typename T1, typename Pred>
inline T1 compare_list(const T0& t0, const T1& t1, Pred&& pred)
{
    T1 result;
    int x,y;
    for( x = 0; x < t0.size(); ++x)
    {
        for( y = 0; y < t1.size(); ++x)
        {
            if(pred(t0[x],t1[y]))
            {
                result << t1[y];
                break;
            }
        }
    }
    return result;
}

// QStringList existencePackages(const QStringList& devPackages, const QStringList & external)
// {
//     QStringList list;
//     int x=0,y;

//     for(;x < devPackages.count(); ++x)
//     {
//         for(y=0;y < external.count(); ++y)
//         {
//             if(devPackages[x] == external[y])
//             {
//                 list << external[y];
//                 break;
//             }
//         }
//     }
//     return list;
// }

// QStringList existencePackageDisables(const QList<PackageIO> & devPackages, const QStringList & external)
// {
//     QStringList list;
//     int x,y;
//     for(x = 0;x < devPackages.count(); ++x)
//     {
//         for(y = 0;y < external.count(); ++y)
//         {
//             if(!devPackages[x].disabled && devPackages[x].packageName == external[y])
//             {
//                 list << external[y];
//                 break;
//             }
//         }
//     }
//     return list;
// }

std::pair<QStringList, int> malwareReadLog(){
    QMutexLocker locker(mutex);
    return {QStringList(std::move(_outputMalware)),mProgress};
}

QString malwareReadHeader()
{
    QMutexLocker locker(mutex);
    return _outputHeader;
}

MalwareStatus malwareStatus(){
    return status;
}

void malwareStart(MainWindow * handler){
    if(malwareThread != nullptr)
    {
        malwareWriteLog("Процесс уже запущен.");
        return;
    }
    mutex = new QMutex();
    mainWindow = handler;
    malwareThread = new QThread();
    QObject::connect(malwareThread, &QThread::started, &malwaring);
    adb = &handler->adb;
    network = new Network(handler);
    network->authedId = handler->network.authedId;
    malwareCmd = 0;
    mProgress = 0;
    status = MalwareStatus::Running;
    malwareThread->start(QThread::HighPriority);
}

bool malwareClean()
{
    if(status == MalwareStatus::Running)
        return false;
    delete network;
    delete mutex;
    malwareThread = nullptr;
    return true;
}

void malwareKill(){
    if(malwareThread == nullptr)
        return;
    malwareCmd = MalwareForclyKill;
}

void malwaring()
{
    using namespace std::chrono;

    int isFinish = 0;
    int lastResult,num0,num1,totalMalware;
    QList<PackageIO> localPackages;
    QEventLoop loop;

    auto procedureStartAt = steady_clock::now();

    std::function<QString(int)> generate_error_report = [](int status)->QString
    {
        QString error;
        if(status == NetworkStatus::ServerError)
            error = ("Ошибка на стороне сервера.");
        else if(status == NetworkStatus::NoEnoughMoney)
            error = ("Пополните баланс, чтобы продолжить.");
        else
            error = (QString("Код ошибки %1").arg(status));
        return error;
    };

    while(!isFinish)
    {
        switch(malwareCmd)
        {
            // INIT
        case 0:
        {
            malwareWriteHeader("Запуск процедуры удаление рекламы (Malware)...", 1);
            malwareUserValue = -1;
            totalMalware = 0;
            malwareCmd++;
            WAITMODE;
            break;
        }
        // GET PACKAGES & UPLOAD
        case 1:
        {
            if(!adb->isConnected())
            {
                malwareWriteHeader("Устройство внезапно отключилась.");
                malwareWriteLog("Пожалуйста, убедитесь что устройство подключено корректно и кабель не поврежден.");
                malwareCmd = MalwareExecFail;
                break;
            }
            malwareWriteHeader(QString("Получение данных с устройства ") + adb->device.displayName + "(" + adb->device.devId + ")", 2);
            localPackages = adb->getPackages();
            if(adb->isConnected())
            {
                if(localPackages.isEmpty())
                {
                    malwareWriteHeader("Получили пустой результат.");
                    malwareCmd = MalwareExecFail;
                    break;
                }
            }
            else
            {
                malwareWriteHeader("Устройство внезапно отключилась.");
                malwareCmd = MalwareExecFail;
                break;
            }
            malwareWriteLog("Распаковка");
            WAITMODE;

            num0 = mProgress;
            num1 = 0;
            for(const PackageIO& pkg : std::as_const(localPackages))
            {
                int curValue = Map<int,int>(num1,0,localPackages.size(),num0,48);
                malwareWriteLog(QString(" >> md5 hash %1").arg(QString(QCryptographicHash::hash(pkg.packageName.toLatin1(), QCryptographicHash::Md5).toHex())), curValue);
                ++num1;
                WAITMODE2;
            }
            malwareWriteHeader("Получение данных завершена успешно.");
            WAITMODE;
            malwareWriteHeader("Анализ и обработка фоновых данных...");
            adb->killPackages(localPackages, lastResult);
            if(localPackages.count() != lastResult)
                malwareWriteLog("Частично.");
            else
                malwareWriteLog("Выполнено.");
            WAITMODE;

            QStringList resultList{},disableList{},localPackageNames;
            LabStatusInfo labs;
            QString mdKey;
            std::transform(localPackages.begin(), localPackages.end(), std::back_inserter(localPackageNames), [](const PackageIO& package){ return package.packageName; });
            QObject::connect(network, &Network::uploadUserPackages, [&lastResult,&labs,&loop](int status, const LabStatusInfo& labsResult, bool ok)
                             {
                                 if(ok)
                                 {
                                     labs = labsResult;
                                 }
                                 lastResult = status;
                                 loop.quit();
                             });
            if(!network->sendUserPackages(adb->device, localPackageNames))
            {
                malwareWriteHeader("Ошибка при отправке");
                malwareWriteLog(generate_error_report(lastResult));
                WAITMODE;
                malwareCmd = MalwareExecFail;
                break;
            }
            malwareWriteLog("Отправка образцов на сервер imister.kz и получение md-ключа", 49);
            loop.exec();
            mdKey = labs.mdKey;
            WAITMODE;

            if(lastResult)
            {
                malwareWriteHeader("Ошибка во время загрузки");
                malwareWriteLog(generate_error_report(lastResult));
                WAITMODE;
                malwareCmd = MalwareExecFail;
                break;
            }

            // Test MDKey
            QObject::connect(network, &Network::fetchingLabs, [&labs,&lastResult,&loop](int status, const LabStatusInfo& labsResult, bool ok)
                             {
                                 if(ok)
                                 {
                                     labs = labsResult;
                                 }
                                 lastResult = status;
                                 loop.quit();
                             });

            if(lastResult)
            {
                malwareWriteHeader("Ошибка проверки ключа");
                malwareWriteLog(generate_error_report(lastResult));
                WAITMODE;
                malwareCmd = MalwareExecFail;
                break;
            }

            int chances = 5;
            if(!labs.ready())
            {
                malwareWriteHeader("Выполняется серверная обработка. Ожидаем. Если пройдет больше времени, то можно попробовать позже.");
                malwareWriteLog("В данный момент ожидается выполнение необходимых действий администратора для продолжения. Ожидайте.");
            }
            mProgress = 49;
            while(labs.exists() && !labs.ready() && chances > 0)
            {
                if(!adb->isConnected())
                {
                    malwareWriteHeader("Устройство внезапно отключилась.");
                    malwareCmd = MalwareExecFail;
                    break;
                }

                network->fetchLabState(mdKey);
                loop.exec();

                WAITMODE2;

                if(lastResult)
                {
                    if(lastResult == NetworkStatus::ServerError)
                        break;
                    --chances;
                }
                else
                {
                    chances = 5;
                }
            }
            mProgress = 50;
            WAITMODE;

            if(lastResult)
            {
                malwareWriteHeader("Возникла ошибка.");
                malwareWriteLog(generate_error_report(lastResult));
                WAITMODE;
                malwareCmd = MalwareExecFail;
                break;
            }

            if(!network->authedId.hasVipAccount() && !labs.purchased)
            {
                malwareUserValue = 1000;
                while(malwareUserValue == 1000)
                {
                    QThread::msleep(100);
                }

                if(malwareUserValue != QMessageBox::StandardButton::Yes)
                {
                    malwareWriteHeader("Запрос отклонен пользователем");
                    malwareWriteLog("вы отказались от оплаты");
                    QThread::msleep(1000);
                    malwareCmd = MalwareExecFail;
                    break;
                }
            }

            if(labs.analyzeStatus == "part-verify")
            {
                malwareWriteHeader("АВТОМАТИЧЕСКИЙ РЕЖИМ (BETA) -- ВЫПОЛНЕНИЕ");
                QThread::msleep(2500);
            }

            malwareWriteLog(QString("md-ключ получен ") + labs.mdKey, 51);
            malwareWriteLog("Применение md-ключа и получение лабараторного анализа.", 52);
            WAITMODE;

            resultList.clear();
            disableList.clear();
            QObject::connect(network, &Network::labAdsFinish, [&](int status, const AdsInfo& adsData, bool ok)
                             {
                                 (void)lastResult;
                                 (void)loop;
                                 if(ok)
                                 {
                                     labs = adsData.labs;
                                     resultList = adsData.blacklist;
                                     disableList = adsData.disabling;
                                 }
                                 lastResult = status;
                                 loop.quit();
                             });
            network->getAdsData(labs.mdKey);
            loop.exec();

            if(lastResult != NetworkStatus::OK)
            {
                malwareWriteHeader("Ошибка во время получения.");
                malwareWriteLog(generate_error_report(lastResult));
                WAITMODE;
                malwareCmd = MalwareExecFail;
                break;
            }
            malwareWriteHeader("Результаты из лаборатории получены.",55);
            WAITMODE;

            PRINT_LINE;
            if(resultList.isEmpty() && disableList.isEmpty())
            {
                malwareWriteHeader("Действий не требуется");
                malwareWriteLog("К сожалению, автоматический режим не обнаружил вредоносного ПО.");
                malwareWriteLog("Если считаете что на устройстве все еще есть рекламные вирусы, пожалуйста свяжитесь с нами.");
                malwareWriteLog("Администратор проверит ваше устройство на наличие рекламных вирусов.", 100);
                malwareCmd++;
                WAITMODE;
                break;
            }

            malwareWriteLog("Распаковка", 57);
            resultList = compare_list(localPackageNames, resultList, [](const auto& lhs, const auto& rhs) -> bool { return lhs == rhs; });
            // resultList = existencePackages(localPackageNames,resultList);
            disableList = compare_list(localPackages, disableList, [](const auto& lhs, const auto& rhs) -> bool { return !lhs.disabled && lhs.packageName == rhs; } );
            //disableList = existencePackageDisables(localPackages,disableList);
            totalMalware = static_cast<int>(resultList.size() + disableList.size());
            WAITMODE;

            num0 = mProgress;
            num1 = 0;
            for(const QString& pkg : std::as_const(resultList))
            {
                ++num1;
                //HAVE
                int curValue = Map<int,int>(num1,0,resultList.size(),num0,80);
                malwareWriteLog(QString(" >> md5 hash %1").arg(QString(QCryptographicHash::hash(pkg.toLatin1(), QCryptographicHash::Md5).toHex())), curValue);
                WAITMODE2;
            }
            WAITMODE;

            malwareWriteHeader("Обезвреживание устройства. Ждите...",81);

            lastResult = 0;
            num1 = static_cast<int>(resultList.size());
            if(!resultList.isEmpty() && !adb->uninstallPackages(resultList,lastResult))
            {
                malwareWriteHeader("Ошибка");
                malwareWriteLog("Что-то пошло не так. Возможно устройство было отключено.");
                malwareWriteLog("Пожалуйста начните процедуру заново.");
                WAITMODE;
                malwareCmd = MalwareExecFail;
                break;
            }
            num0 = lastResult;
            if(!disableList.isEmpty())
            {
                num1 += static_cast<int>(disableList.size());
                if(!adb->disablePackages(disableList, lastResult))
                {
                    malwareWriteHeader("Ошибка");
                    malwareWriteLog("Что-то пошло не так. Возможно устройство было отключено.");
                    malwareWriteLog("Пожалуйста начните процедуру заново.");
                    WAITMODE;
                    malwareCmd = MalwareExecFail;
                    break;
                }
                num0 += lastResult;
            }

            mProgress = Map<int,int>(num0, 1, num1, mProgress, 99);
            if(num0 != num1)
                malwareWriteLog("Предупреждение: Процесс частично успешен. Повторите.");
            else
                mProgress = 99;
            malwareCmd++;
            break;
        }
        default:
            PRINT_LINE;

            QThread::msleep(2000);

            isFinish = 1;
            if(malwareCmd < 0)
            {
                malwareWriteHeader("Процедура завершилась ошибкой. Повторите.");
                status = MalwareStatus::Error;
            }
            else
            {
                QString text = "Процедура завершена.";
                auto durationProcedure = duration_cast<seconds>(steady_clock::now() - procedureStartAt);
                if(totalMalware)
                {
                    text += " Рекламных вирусов удалено %1.";
                    text = text.arg(totalMalware);
                }
                text += " Затрачено времени %1 с";
                text = text.arg(durationProcedure.count());

                malwareWriteHeader(text,100);
                status = MalwareStatus::Idle;
            }
            break;
        }
    }
}

#undef WAITMODE
